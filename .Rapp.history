Beta_centered
beta <- as.vector(t(Beta_centered))
beta
t(Beta_centered)
mean(beta)
round(mean(beta), 3)
Beta_uncentered
mean(Beta_uncentered)
J <- 50                  # number of persons
theta <- rnorm(J, 0, 1)  # latent ability for each person
I <- 10                                      # number of items
alpha <- rep(c(0.7, 0.8, 0.9, 1, 1.2), length.out = I) # item discrimination parameter
alpha
Beta_uncentered <- matrix(NA, nrow = I, ncol = 2)
Beta_uncentered[, 1] <- seq(from = -1.5, to = 1.5, length.out = I)
Beta_uncentered[, 2] <- Beta_uncentered[, 1] + rep(c(0.25, 0.5, 0.75, 1, 1.25), length.out = I)
Beta_centered <- Beta_uncentered - mean(Beta_uncentered)
Beta_uncentered
Beta_centered
mean(Beta_uncentered)
mean(Beta_centered)
round(mean(Beta_centered), 3)
beta <- as.vector(t(Beta_centered))
beta
t(Beta_centered)
data_list <- list(I = I, #
                  J = J, #
                  N = I * J, #
                  ii = rep(1 : I, times = J),  #
                  jj = rep(1 : J, each = I))
data_list
unsummed <- c(0, alpha * (theta - beta))
Beta_centered
simulate_response <- function(theta, alpha, beta) {#
    unsummed <- c(0, alpha * (theta - beta))#
    numerators <- exp(cumsum(unsummed))#
    denominator <- sum(numerators)#
    response_probs <- numerators/denominator#
    simulated_y <- sample(1:length(response_probs) - 1, size = 1, prob = response_probs)#
    return(unsummed, numerators, denominator, response_probs, simulated_y)#
}
data_list$y <- numeric(data_list$N)#
for (n in 1:data_list$N) {#
    data_list$y[n] <- simulate_response(theta[data_list$jj[n]],  #
                                        alpha[data_list$ii[n]], #
                                        Beta_centered[data_list$ii[n], ])#
}
simulate_response <- function(theta, alpha, beta) {#
    unsummed <- c(0, alpha * (theta - beta))#
    numerators <- exp(cumsum(unsummed))#
    denominator <- sum(numerators)#
    response_probs <- numerators/denominator#
    simulated_y <- sample(1:length(response_probs) - 1, size = 1, prob = response_probs)#
    return(list(unsummed, numerators, denominator, response_probs, simulated_y))#
}
data_list$y <- numeric(data_list$N)#
for (n in 1:data_list$N) {#
    data_list$y[n] <- simulate_response(theta[data_list$jj[n]],  #
                                        alpha[data_list$ii[n]], #
                                        Beta_centered[data_list$ii[n], ])#
}
# Function to simulate responses#
simulate_response <- function(theta, alpha, beta) {#
    unsummed <- c(0, alpha * (theta - beta))#
    numerators <- exp(cumsum(unsummed))#
    denominator <- sum(numerators)#
    response_probs <- numerators/denominator#
    simulated_y <- sample(1:length(response_probs) - 1, size = 1, prob = response_probs)#
    return(simulated_y)#
}
data_list$y <- numeric(data_list$N)#
for (n in 1:data_list$N) {#
    data_list$y[n] <- simulate_response(theta[data_list$jj[n]],  #
                                        alpha[data_list$ii[n]], #
                                        Beta_centered[data_list$ii[n], ])#
}
data_list$y
unsummed <- c(0, alpha[data_list$ii[1]] * (theta[data_list$jj[1] - Beta_centered[data_list$ii[1], ]))
unsummed <- c(0, #
     alpha[data_list$ii[1]] * (theta[data_list$jj[1]] - Beta_centered[data_list$ii[1], ]))
unsummed
numerators <- exp(cumsum(unsummed))
numerators
cumsum(unsummed)
denominator <- sum(numerators)
denominator
response_probs <- numerators/denominator
response_probs
numerators
simulated_y <- sample(1:length(response_probs) - 1, size = 1, prob = response_probs)
simulated_y
length(response_probs) - 1
response_probs
simulated_y <- sample(1:length(response_probs), size = 1, prob = response_probs)
simulated_y
response_probs
1:length(response_probs) - 1
1:length(response_probs)
simulated_y <- sample(1:length(response_probs) - 1, size = 3, prob = response_probs)
simulated_y
simulated_y <- sample(1:length(response_probs) - 1, size = 5, prob = response_probs)
simulated_y <- sample(1:length(response_probs) - 1, size = 2, prob = response_probs)
simulated_y
response_probs
1:length(response_probs) - 1
response_probs
sun(response_probs)
sum(response_probs)
unsummed <- c(0, alpha[data_list$ii[1]] * (theta[data_list$jj[1]] - Beta_centered[data_list$ii[1], ]))
unsummed
response_probs
denominator
numerators <- exp(cumsum(unsummed))
numerators
a <- runif(I, -.5, 1.5) # item discrimination parameter
a
a <- runif(I, .5, 1.5) # item discrimination parameter
a
a <- runif(I, .75, 1.25) # item discrimination parameter
a
b_uncentered[, 1] <- rnorm(I, 0, 1)
b_uncentered <- matrix(NA, nrow = I, ncol = 2)
b_uncentered[, 1] <- rnorm(I, 0, 1)
b_uncentered[, 2] <- b_uncentered[, 1] + runif(I, .2, .7)
b_uncentered
mean(b_uncentered)
b <- b_uncentered - mean(b_uncentered)
round(mean(b), 3)
b
obs = I * J
obs <- I * J #
ii  <- rep(1 : I, times = J),  #
jj  <- rep(1 : J, each = I))
ii  <- rep(1 : I, times = J)
jj  <- rep(1 : J, each = I)
y <- numeric(obs)
y
i  <- rep(1 : I, times = J)  #
j  <- rep(1 : J, each = I)
simulate_response <- function(theta, alpha, beta) {#
    unsummed <- c(0, alpha * (theta - bethetaa))#
    numerators <- exp(cumsum(unsummed))#
    denominator <- sum(numerators)#
    response_probs <- numerators/denominator#
    y <- sample(1:length(response_probs) - 1, size = 1, prob = response_probs)#
    return(y)#
}#
#
y <- numeric(obs)#
#
for (n in 1 : obs) {#
    y[n] <- simulate_response(theta[j[n]], a[i[n]], b[i[n], ])#
}
for (n in 1 : obs) {#
    y[n] <- simulate_response(t[j[n]], a[i[n]], b[i[n], ])#
}
j
obs
y <- numeric(obs)#
#
for (n in 1 : obs) {#
    ii <- i[n]#
    jj <- j[n]#
    y[n] <- simulate_response(t[jj], a[ii], b[ii], ])#
}
for (n in 1 : obs) {#
    ii <- i[n]#
    jj <- j[n]#
    y[n] <- simulate_response(t[jj], a[ii], b[ii, ])#
}
j  <- rep(1 : J, each = I)
j
i[1]
j[1]
t
t <- rnorm(J, 0, 1)  # latent ability for each person
t
for (n in 1 : obs) {#
    ii <- i[n]#
    jj <- j[n]#
    y[n] <- simulate_response(t[jj], a[ii], b[ii, ])#
}
simulate_response <- function(theta, alpha, beta) {#
    unsummed <- c(0, alpha * (theta - beta))#
    numerators <- exp(cumsum(unsummed))#
    denominator <- sum(numerators)#
    response_probs <- numerators/denominator#
    y <- sample(1:length(response_probs) - 1, size = 1, prob = response_probs)#
    return(y)#
}
for (n in 1 : obs) {#
    ii <- i[n]#
    jj <- j[n]#
    y[n] <- simulate_response(t[jj], a[ii], b[ii, ])#
}
for (n in 1 : obs) {#
    #ii <- i[n]#
    #jj <- j[n]#
    y[n] <- simulate_response(t[j[n]], a[i[n]], b[i[n], ])#
}
k <- 2  # number of thresholds#
#
#==============================================================================##
#  TO DO!#
#  Generalize b_uncentered to accomoate k thersholds#
#==============================================================================##
#
# bs are the thresholds, for three outcomes, there are 2 betas (step functions)#
# Empty I * K matrix where I is number of items and K is number of thresholds#
# For varied numbed of responses, this will need to be a list.#
b_uncentered <- matrix(NA, nrow = I, ncol = k)#
#
# First threholds gets increasingly more difficulty #
# Thresholds could be sampled from some distribution e.g., rnorm().#
b_uncentered[, 1] <- rnorm(I, 0, 1) #
#
# The 2nd threshold is the first threshold + a difference .#
# Could be also be sampled from a distribution e.g., runif(). #
b_uncentered[, 2] <- b_uncentered[, 1] + runif(I, .2, .7)#
mean(b_uncentered)#
#
# Cumulative proabilities such that the average is 0#
b <- b_uncentered - mean(b_uncentered)#
round(mean(b), 3)
J <- 50                  # number of persons
t <- rnorm(J, 0, 1)  # latent ability for each person
I <- 10                 # number of items
a <- runif(I, .75, 1.25) # item discrimination parameter
k <- 2  # number of thresholds
b_uncentered <- matrix(NA, nrow = I, ncol = k)
b_uncentered[, 1] <- rnorm(I, 0, 1)
b_uncentered[, 2] <- b_uncentered[, 1] + runif(I, .2, .7)
mean(b_uncentered)
# Cumulative proabilities such that the average is 0
b <- b_uncentered - mean(b_uncentered)
round(mean(b), 3)
b
b[c(3, 5, 9) , 2] <- NA
b
obs <- I * J
i  <- rep(1 : I, times = J)
j  <- rep(1 : J, each = I)
simulate_response <- function(theta, alpha, beta) {#
    unsummed <- c(0, alpha * (theta - beta))#
    numers <- exp(cumsum(unsummed))#
    denom <- sum(numers)#
    response_pr <- numers/denom#
    y <- sample(1:length(response_pr) - 1, size = 1, prob = response_probs)#
    return(y)#
}
y <- numeric(obs)
for (n in 1 : obs) y[n] <- simulate_response(theta = t[j[n]], alpha = a[i[n]], beta = b[i[n], ])
k <- runif(n = I, 1, 3)
k
k <- round(runif(n = I, 1, 3))
k <- sample(x = 1:3, size = 1)
k
k <- sample(x = 1:3, size = 10)
k
k <- sample(x = 1:3, size = 10, replace = T)
k
k <- sample(x = 1:3, size = 10, replace = T, prob = c(.5, .35, .15))
k
b <- list(i01 = c(-.3, .2), #
          i02 = c(.25),#
          i03 = c(-.75, -.1, .3),#
          i04 = c(.4),#
          i05 = c(-.2, .3, .65), #
          i06 = c(1.2),#
          i07 = c(-1.1),#
          i08 = c(.1, .7, 1.4),#
          i09 = c(-1.4, -.9, -.2),#
          i10 = c(4., .9, 1.5) )
b
obs <- I * J
i  <- rep(1 : I, times = J)
j  <- rep(1 : J, each = I)
simulate_response <- function(theta, alpha, beta) {#
    unsummed <- c(0, alpha * (theta - beta))#
    numers <- exp(cumsum(unsummed))#
    denom <- sum(numers)#
    response_pr <- numers/denom#
    y <- sample(1:length(response_pr) - 1, size = 1, prob = response_probs)#
    return(y)#
}
y <- numeric(obs)
for (n in 1 : obs) y[n] <- simulate_response(theta = t[j[n]], alpha = a[i[n]], beta = b[[i[n], ]])
b[[1]]
b[[1, 2]]
b[[1]][1]
for (n in 1 : obs) y[n] <- simulate_response(theta = t[j[n]], alpha = a[i[n]], beta = b[[i]])
b[[1]]
for (n in 1 : obs) y[n] <- simulate_response(theta = t[j[n]], alpha = a[i[n]], beta = b[[i[n]]])
b[[i[1]]]
y
for (n in 1 : obs) y[n] <- simulate_response(theta = t[j[n]], alpha = a[i[n]], beta = b[[i[n]]])
simulate_response <- function(theta, alpha, beta) {#
    unsummed <- c(0, alpha * (theta - beta))#
    numers <- exp(cumsum(unsummed))#
    denom <- sum(numers)#
    response_pr <- numers/denom#
    y <- sample(1:length(response_pr) - 1, size = 1, prob = response_pr)#
    return(y)#
}
for (n in 1 : obs) y[n] <- simulate_response(theta = t[j[n]], alpha = a[i[n]], beta = b[[i[n]]])
y
mean(b)
mean(unlist(b))
b <- b - mean(unlist(b))
b <- lapply(bm funtion(x) x - mean(unlist(x))
b <- lapply(b, funtion(x) x - mean(unlist(x))
b <- lapply(b, function(x) x - mean(unlist(x))
b
b <- list(i01 = c(-.3, .2), #
          i02 = c(.25),#
          i03 = c(-.75, -.1, .3),#
          i04 = c(.4),#
          i05 = c(-.2, .3, .65), #
          i06 = c(1.2),#
          i07 = c(-1.1),#
          i08 = c(.1, .7, 1.4),#
          i09 = c(-1.4, -.9, -.2),#
          i10 = c(4., .9, 1.5) )
b
b_mean <- mean(unlist(x)
b_mean
b_mean <- mean(unlist(x))
b_mean <- mean(unlist(b))
b_mean
b1 <- lapply(b, function(x) x - b_mean)
b1
mean(unlist(b1))
round(mean(unlist(b1)))
i <- 10                 # number of items
a <- runif(i, .75, 1.25) # item discrimination parameter
k <- sample(x = 1:3, size = i, replace = T, prob = c(.5, .35, .15))
k
setwd("Dropbox/Research/ilsasim")
source("R/population_pars.R")     # generate population parameter for questionnaire_gen #
source("R/questionnaire_gen.R")   # generate questionnaire data, including theta#
source("R/item_gen.R")            # generate item parameters (if you don't have your own!)#
source("R/irt_gen.R")             # generate responses based on theta and item parameters#
source("R/book_gen.R")            # generate booklet design (can provide your own boo)#
source("R/response_gen.R")        # generate response data#
source("R/test_assembly.R")       # generate response data
n_subj   <- 10                  # number of students#
n_vars   <- 20                  # number of questionnaire variables#
n_forms  <- 5                   # number of test forms#
form_len <- 10                   # number of items per form#
n_items  <- n_forms * form_len  # number of total items
cat_pr1 <- rand_cum_proportions(n_var = n_vars, max_category = 3)
cat_pr1
cat_pr1 <- rand_cum_proportions(n_var = n_vars, max_category = 3)
cat_pr1
q1 <- rand_pd_corr(n_var = n_vars)
q1
surv1 <- questionnaire(n = n_subj, cat_prop = cat_pr1, cor_matrix = q1)
surv1
runif(1, 0, 0)
#--- item parameter generation partial credit#
genGPCM <- item_gen(n_items   = n_items, #
                    b_bounds  = c(-2, 2),#
                    a_bounds  = c(-.5, 1.75),#
                    c_bounds  = c(0, 2), #
                    k_options = 1:3, #
                    k_proportions = c(.5, .3, .2))
genGPCM
test1
test1 <- test_assembly(n_subj = n_subj, n_forms = n_forms, form_length = form_len)
test1
datGPCM <- response_gen(subject = test1$item_assign$subject, #
                        item    = test1$item_assign$item, #
                        theta   = surv1$theta, #
                        b_par   = genGPCM$b,#
                        a_par   = genGPCM$a,#
                        c_per   = genGPCM$c)
test1$item_assign$subject
test1$item_assign$item
surv1$theta
genGPCM$c
genGPCM
genGPCM$a_par
datGPCM <- response_gen(subject = test1$item_assign$subject, #
                        item    = test1$item_assign$item, #
                        theta   = surv1$theta, #
                        b_par   = genGPCM$b_par,#
                        a_par   = genGPCM$a_par,#
                        c_per   = genGPCM$c_par)
#--- item responses #
datGPCM <- response_gen(subject = test1$item_assign$subject, #
                        item    = test1$item_assign$item, #
                        theta   = surv1$theta, #
                        b_par   = genGPCM$b_par,#
                        a_par   = genGPCM$a_par,#
                        c_par   = genGPCM$c_par)
datGPCM
final_data <- merge(surv1, datGPCM, by = "subject")
str(final_data)
n <- 20
frm <- 8
frm_l <- 5
itm <- frm*frm_l
spiral <- c(1,2, 2,3, 3,4, 4,5, 5,6, 6,7, 7,8, 8,1, 1,5, 2,6, 3,7, 4,8)
books <- matrix(spiral, ncol = 2, byrow = T)
books
itm
test3 <- test_assembly(n_subj = n, n_forms = frm, form_length = frm_l, book_design = books)
n <- 100
frm <- 8
frm_l <- 5
itm <- frm*frm_l
spiral <- c(1,2, #
            2,3, #
            3,4, #
            4,5, #
            5,6, #
            6,7, #
            7,8, #
            8,1, #
            1,5, #
            2,6, #
            3,7, #
            4,8)
test3 <- test_assembly(n_subj = n, n_forms = frm, form_length = frm_l, book_design = books)
test3
n <- 100
frm <- 8
frm_l <- 5
itm <- frm*frm_l
spiral <- c(1,2, #
            2,3, #
            3,4, #
            4,5, #
            5,6, #
            6,7, #
            7,8, #
            8,1, #
            1,5, #
            2,6, #
            3,7, #
            4,8)#
books <- matrix(spiral, ncol = 2, byrow = T)
test3 <- test_assembly(n_subj = n, n_forms = frm, form_length = frm_l, book_design = books)
head(test3$book_assign)
test3$items_per_book
test3 <- test_assembly(n_subj = n, n_forms = frm, form_length = frm_l, book_design = books)
test3$items_per_book
theta <- rnorm(n, 0, 1)
gen1PL <- item_gen(n_items  = itm, #
                   b_bounds = c(-2, 2))#
str(gen1PL)
dat1PL <- response_gen(subject = test3$item_assign$subject, #
                       item    = test3$item_assign$item, #
                       theta   = theta, #
                       b_par   = gen1PL$b_par)
dat1PL
gen1PL
gen2PL <- item_gen(n_items  = itm, #
                   b_bounds = c(-2, 2),#
                   a_bounds = c(-.5, 1.75))#
#
dat2PL <- response_gen(subject = test3$item_assign$subj, #
                       item    = test3$item_assign$item, #
                       theta   = theta, #
                       b_par  = gen2PL$b,#
                       a_par  = gen2PL$a)
gen2PL
genRPCM <- item_gen(n_items       = itm, #
                    b_bounds      = c(-2, 2),#
                    k_options     = 1:3, #
                    k_proportions = c(.5, .3, .2))#
datRPCM <- response_gen(subject = test3$item_assign$subj, #
                        item    = test3$item_assign$item, #
                        theta   = theta, #
                        b_par   = genRPCM$b,#
                        a_par   = genRPCM$a)
genRPCM
