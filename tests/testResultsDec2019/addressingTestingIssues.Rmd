---
title: "Issues from December testing session"
author: "Waldir Leoncio"
date: 2020-01-16
output:
  html_document:
    toc: true
---

# Introduction

This document addresses issues raised from the lsasim testing session on 2019-12-16. The output is not shown will reflect the latest development stage of lsasim, so it will not necessarity correspond to the behavior observed by the users during the testing session. However, the issues raised will be acknowledged whenever they were reproducible.

The latest development version of lsasim at the time this document was created is `r packageVersion("lsasim")`.

Test units have been put in place to prevent the issues raised to creep up in future versions of the package.

# Yi.txt

The content of the file is reproduced below:

> There seems a bug about the ranges function, for example:
> n1 <- list(school = ranges(5, 10), student = ranges(10, 20))
> N1 = c (150,40)
> 
> then, when I run draw_cluster_structure(n1, N1) or cluster_gen(n1), everything is good;
> but when I run cluster_gen(n1, N1) or cluster_gen(n1, N1, n_X=2, n_W=2), the number of school goes very big, such as 107 and 127

## Reproducing the issue

### What went well

```{r yi-setup}
library(lsasim)
n1 <- list(school = ranges(5, 10), student = ranges(10, 20))
N1 <- c(150,40)
```

Since `n1` was defined with `ranges()`, the code below will generate a different structure each time it is called. In any case, the number of schools will be sampled from a discrete U(5, 10) and the number of students from U(10, 20).

One issue with running `draw_cluster_structure` with the argument set `{n1, N1}` is that the two first arguments of this function are, in order, "n" and "labels", so calling `draw_cluster_structure(n1, N1)` will attribute `N1` to the labels of `n1`, as seen below:

```{r yi-draw-N1-labels}
draw_cluster_structure(n1, N1)
```

A more proper way to print the structure is by calling as below. The function is called twice here to show that each call to it will generate different sample sizes.

```{r yi-structure}
draw_cluster_structure(n1)
draw_cluster_structure(n1)
```

As reported, running `cluster_gen(n1)` will generate data as expected. Since this call to `cluster_gen` is independent from the `draw_cluster_structure` calls above, the sample sizes will differ once again.

```{r yi-gen-1}
df1 <- cluster_gen(n1)
lapply(df1, function(s) lapply(s, head)) 
```

The `lapply` call above simply applies `head()` to the elements of `df1` (i.e., each school dataset); this saves space by printing only the 6 first elements of each school.

### What did not go well

The user reported issues when the following is ran:

```{r yi-problem, eval=FALSE}
df2 <- cluster_gen(n1, N1)
df3 <- cluster_gen(n1, N1, n_X=2, n_W=2)
```

This is indeed observed in lsasim 2.0.1.9001, where the Sampled structure is not drawn from U(5, 10) anymore, it is just as large as the population. This was observed both visually and by running, for example, `length(df2$school)`, which outputs a large number of sampled schools.

## Identifying the issue

The issue has been found to be in the `convert_vector_to_list` function, which converts a vector to list where each element is replicated a certain number of times depending on the previous vector. It can be called as `convert_vector_to_list(n)` or as `convert_vector_to_list(n, N)`. On the latter case, N should work as a limiter for n. When both n and N are ranges, though, the function doesn't work properly, as n will be only limited by N and not by both N and itself.

## Fixing the issue

Code has been modified on `convert_vector_to_list` to define an upper limit to the sample size considering both the limits set for n as well as for N. The fix can be seen below (`print_pop_structure = FALSE` saves space by suppressing the printing of the population structure of 150 schools)

```{r yi-fixed}
df4 <- cluster_gen(n1, N1, print_pop_structure = FALSE)
df5 <- cluster_gen(n1, N1, n_X=2, n_W=2, print_pop_structure=FALSE)
```

# correlation-matrix-in-cluster_gen.pdf

The content of the file will be reproduced in the following subsections.

## Issue #1: improper correlation matrices

### Reproducing the issue

The basic setup for the first issue raised is as follows:

```{r montse-matrix3}
n3 <- c(5, 15)
N3 <- c(150, 40)
matrix3 <- matrix(
    c(
        .3, .3, .6, -1.03,
        .3,  1, .7, .4,
        .6, .7,  1, .8,
        -1.03, .4, .8,  1
    ),
    nrow = 4, ncol = 4, byrow=T
)
```

This setup raises errors when calling

```{r montse-error1, eval=FALSE}
set.seed(2345)
cluster_gen(n3, N3, n_X = 2, cor_matrix = matrix3, n_W = 2)
```

### Identifying the issue

The user reported the following:

> When I have some misspecification in the diagonal of ones in the correlation matrix it trows an error: Errorin chol.default(cor_matrix) : the leading minor of order 3 is not positive definite

This is indeed the case, as an improper correlation matrix will generate errors in the generation of data. This behavior is present since lsasim 1.0.0 and can be reproduced by issuing the following:

```{r errors-matrix3, eval=FALSE}
questionnaire_gen(5, n_X = 2, cor_matrix = matrix3)
```

Data can be generated even with such improper matrices, as long as `family = "gaussian"` is provided:

```{r errors-matrix3-gaussian, eval=FALSE}
questionnaire_gen(5, n_X = 2, cor_matrix = matrix3, family = "gaussian")
```

The differing behavior is caused by `family = NULL` triggering the default data-generation process of `questionnaire_gen`, which uses Cholesky decomposition, and there are no validation checks in the `chol.default` function; `family = "gaussian"`, on the other hand, uses the function `rmvnorm` to generate the data from a multivariate normal distribution. The latter function makes little judgement of the covariate matrix which is passed, and is able to generate data even if the matrix is not positive semidefinite. See the example below, which contains such a matrix:

```{r example-mvtnorm}
mvtnorm::rmvnorm(
    n = 2,
    mean = c(3, 0),
    sigma = matrix(c(1, 2, 2, 1), 2)
)
```

The problem persists with the matrix below:

```{r matrix4}
matrix4 <- matrix(
    c(
        1, .3, .6, -1.03,
        .3, 1, .7, .4,
        .6, .7, 1, .8,
        -1.03, .4, .8, 1),
    nrow = 4, ncol = 4, byrow=T
)
```

Those issues are expected, as both matrices are not positive semidefinite. This means that their eigenvalues are not all non-negative:

```{r eigen}
eigen(matrix3)$values
eigen(matrix4)$values
```

Naturally, the problem dissappear as proper matrices are provided. For instance, assuming the first variable is inversely correlated to the others:

```{r montse-matrix3-pos}
matrix3_pos <- matrix(
    c(
        1, -.3, -.6, -.5,
        -.3,  1, .7, .4,
        -.6, .7,  1, .8,
        -.5, .4, .8,  1
    ),
    nrow = 4, ncol = 4, byrow=T
)
eigen(matrix3_pos)$values
df1 <- cluster_gen(n3, N3, n_X = 2, cor_matrix = matrix3_pos, n_W = 2)
```

### Fixing the issue

The `questionnaire_gen` function nas been given a new validation check which prevents improper correlation matrices to be passed. This is the current new behavior:

```{r montse-fixed, error=TRUE}
cluster_gen(n3, N3, n_X = 2, cor_matrix = matrix3, n_W = 2, print_pop_structure=FALSE)
cluster_gen(n3, N3, n_X = 2, cor_matrix = matrix4, n_W = 2, print_pop_structure=FALSE)
cluster_gen(n3, N3, n_X = 2, cor_matrix = matrix3, n_W = 2, print_pop_structure=FALSE, family = "gaussian")
```

## Issue #2: failure to produce data

According to the user:

> cluster_gen wonâ€™t produce data if the dimension of the correlation matrix is smaller than the sum of the continuous and categorical variable

```{r error-matrix5, eval=FALSE}
matrix5 <- matrix(
    c(1, .3, .6, .3, 1, .7, .6, .7, 1), nrow = 3, ncol = 3, byrow=T
)
set.seed(2345)
cluster_gen(n3, N3, n_X = 2, cor_matrix = matrix5, n_W = 2)
```

### Identifying the issue

As reported by lsasim, the issue is caused by the fact that the matrix provided matrix5 has fewer columns (3) than the sum of `n_X` and `n_W` (2 + 2 = 4).

### Fixing the issue

The validation check of `questionnaire_gen` has been improved to show the results of the sums, thus making it easier for the user to identify the problem:

```{r matrix5-fix, error=TRUE}
cluster_gen(n3, N3, n_X = 2, cor_matrix = matrix5, n_W = 2, print_pop_structure=FALSE)
```

## Issue #3: miscellaneous issues

The author found some code at the end of the user's report, containing code similar to the one below, where the following was changed to generate proper output:

- `matrix6` was defined as having 5 rows and 5 columns (instead of 3).
- `df6` was complemented with `theta = TRUE` to ensure that `n_X + n_W + theta = ncol(matrix6)` (otherwise, no data is generated, as it falls in the case of issue # 2).

```{r misc1, error=TRUE}
matrix6 <- matrix(
    c(
        1, .3, .6, .8, .5,
        .3,  1, .7, .5, .4,
        .6, .7,  1, .8, .3,
        .8, .5, .8,  1, .2,
        .5, .4, .3, .2,  1
    ),
    nrow = 5, ncol = 5, byrow=T
)
set.seed(2345)
df6 <- cluster_gen(n3, N3, n_X = 2, cor_matrix = matrix6, n_W = 2, print_pop_structure=FALSE)
```

```{r misc2}
n4 <- c(5, 15)
N4 <- c(150, 40)
matrix4 <- matrix(
    c(
        1, .3, .6, .5,
        .3,  1, .7, .4,
        .6, .7,  1, .8,
        .5, .4, .8,  1
    ),
    nrow = 4, ncol = 4, byrow=T
)
c_mean <- c(1,2)
sigma <- c(1.25, 1.50)
set.seed(2345)
data3 <- cluster_gen(n3, N3, n_X = 2, cor_matrix = matrix4, n_W = 2, print_pop_structure=FALSE)
data3$school[[1]]
data3$school[[2]]
```